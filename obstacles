import numpy as np
from casadi import MX, vertcat, sqrt, sum1, sum2, jacobian
from abc import ABC, abstractmethod
import casadi

class ObstacleBase(ABC):
    """Classe de base pour tous les obstacles"""
    
    def __init__(self, name="obstacle"):
        self.name = name
        self.enabled = True
        
    @abstractmethod
    def get_constraint(self, x, y, z=None):
        """Retourne la contrainte symbolique pour cet obstacle
        
        Args:
            x, y, z: Variables symboliques CasADi représentant la position
            
        Returns:
            constraint: Expression CasADi où constraint >= 0 signifie hors obstacle
        """
        pass
    
    @abstractmethod
    def get_bounds(self):
        """Retourne les bornes pour cette contrainte
        
        Returns:
            (lower_bound, upper_bound): Tuple des bornes
        """
        pass
    
    def enable(self):
        """Active cet obstacle"""
        self.enabled = True
        
    def disable(self):
        """Désactive cet obstacle"""
        self.enabled = False


class CircleObstacle(ObstacleBase):
    """Obstacle circulaire en 2D"""
    
    def __init__(self, center_x, center_y, radius, name="circle"):
        super().__init__(name)
        self.center_x = center_x
        self.center_y = center_y
        self.radius = radius
        
    def get_constraint(self, x, y, z=None):
        """Contrainte: (x-cx)² + (y-cy)² >= r²"""
        dx = x - self.center_x
        dy = y - self.center_y
        return dx**2 + dy**2 - self.radius**2
    
    def get_bounds(self):
        """Pour un obstacle dur, on veut constraint >= 0"""
        return (0.0, np.inf)
    
    def update_params(self, center_x=None, center_y=None, radius=None):
        """Met à jour les paramètres de l'obstacle"""
        if center_x is not None:
            self.center_x = center_x
        if center_y is not None:
            self.center_y = center_y
        if radius is not None:
            self.radius = radius


class SphereObstacle(ObstacleBase):
    """Obstacle sphérique en 3D"""
    
    def __init__(self, center_x, center_y, center_z, radius, name="sphere"):
        super().__init__(name)
        self.center_x = center_x
        self.center_y = center_y
        self.center_z = center_z
        self.radius = radius
        
    def get_constraint(self, x, y, z):
        """Contrainte: (x-cx)² + (y-cy)² + (z-cz)² >= r²"""
        dx = x - self.center_x
        dy = y - self.center_y
        dz = z - self.center_z
        return dx**2 + dy**2 + dz**2 - self.radius**2
    
    def get_bounds(self):
        return (0.0, np.inf)
    
    def update_params(self, center_x=None, center_y=None, center_z=None, radius=None):
        if center_x is not None:
            self.center_x = center_x
        if center_y is not None:
            self.center_y = center_y
        if center_z is not None:
            self.center_z = center_z
        if radius is not None:
            self.radius = radius


class RectangleObstacle(ObstacleBase):
    """Obstacle rectangulaire en 2D"""
    
    def __init__(self, x_min, x_max, y_min, y_max, name="rectangle"):
        super().__init__(name)
        self.x_min = x_min
        self.x_max = x_max
        self.y_min = y_min
        self.y_max = y_max
        
    def get_constraint(self, x, y, z=None):
        """Contrainte: point à l'extérieur du rectangle
        Utilise la distance signée au rectangle"""
        # Distance au rectangle (négative si à l'intérieur)
        dx = MX.fmax(MX.fmax(self.x_min - x, 0), MX.fmax(x - self.x_max, 0))
        dy = MX.fmax(MX.fmax(self.y_min - y, 0), MX.fmax(y - self.y_max, 0))
        return dx**2 + dy**2
    
    def get_bounds(self):
        return (1e-6, np.inf)  # Petite valeur positive pour éviter d'être exactement sur le bord
    
    def update_params(self, x_min=None, x_max=None, y_min=None, y_max=None):
        if x_min is not None:
            self.x_min = x_min
        if x_max is not None:
            self.x_max = x_max
        if y_min is not None:
            self.y_min = y_min
        if y_max is not None:
            self.y_max = y_max


class BoxObstacle(ObstacleBase):
    """Obstacle parallélépipédique en 3D"""
    
    def __init__(self, x_min, x_max, y_min, y_max, z_min, z_max, name="box"):
        super().__init__(name)
        self.x_min = x_min
        self.x_max = x_max
        self.y_min = y_min
        self.y_max = y_max
        self.z_min = z_min
        self.z_max = z_max
        
    def get_constraint(self, x, y, z):
        """Contrainte: point à l'extérieur du parallélépipède"""
        dx = MX.fmax(MX.fmax(self.x_min - x, 0), MX.fmax(x - self.x_max, 0))
        dy = MX.fmax(MX.fmax(self.y_min - y, 0), MX.fmax(y - self.y_max, 0))
        dz = MX.fmax(MX.fmax(self.z_min - z, 0), MX.fmax(z - self.z_max, 0))
        return dx**2 + dy**2 + dz**2
    
    def get_bounds(self):
        return (1e-6, np.inf)
    
    def update_params(self, x_min=None, x_max=None, y_min=None, y_max=None, 
                     z_min=None, z_max=None):
        if x_min is not None:
            self.x_min = x_min
        if x_max is not None:
            self.x_max = x_max
        if y_min is not None:
            self.y_min = y_min
        if y_max is not None:
            self.y_max = y_max
        if z_min is not None:
            self.z_min = z_min
        if z_max is not None:
            self.z_max = z_max

class ObstacleManager:
    """Gestionnaire des obstacles pour le MPC"""
    
    def __init__(self):
        self.obstacles = []
        
    def add_obstacle(self, obstacle):
        """Ajoute un obstacle"""
        self.obstacles.append(obstacle)
        
    def remove_obstacle(self, obstacle_name):
        """Supprime un obstacle par nom"""
        self.obstacles = [obs for obs in self.obstacles if obs.name != obstacle_name]
        
    def clear_obstacles(self):
        """Supprime tous les obstacles"""
        self.obstacles = []
        
    def get_obstacle(self, name):
        """Récupère un obstacle par nom"""
        for obs in self.obstacles:
            if obs.name == name:
                return obs
        return None
        
    def get_constraints(self, state_vars, position_indices):
        """Génère toutes les contraintes d'obstacles
        
        Args:
            state_vars: Variables d'état symboliques CasADi
            position_indices: Dict avec les indices des positions {'x': idx, 'y': idx, 'z': idx}
            
        Returns:
            constraints: Liste des contraintes symboliques
            bounds: Liste des tuples (lower_bound, upper_bound)
        """
        constraints = []
        bounds = []
        
        for obstacle in self.obstacles:
            if not obstacle.enabled:
                continue
                
            # Extraction des variables de position
            x = state_vars[position_indices['x']]
            y = state_vars[position_indices['y']]
            z = None
            if 'z' in position_indices and position_indices['z'] is not None:
                z = state_vars[position_indices['z']]
            # Génération de la contrainte
            constraint = obstacle.get_constraint(x, y, z)
            bound = obstacle.get_bounds()
            
            constraints.append(constraint)
            bounds.append(bound)
            
        return constraints, bounds
    
    def get_active_obstacles(self):
        """Retourne la liste des obstacles actifs"""
        return [obs for obs in self.obstacles if obs.enabled]
    
    def get_obstacle_names(self):
        """Retourne la liste des noms d'obstacles"""
        return [obs.name for obs in self.obstacles]
    
        from casadi import jacobian
    
    def get_constraints_and_gradients(self, state_vars, state_lin, position_indices):
        constraints = []
        bounds = []
        for obstacle in self.obstacles:
            if not obstacle.enabled:
                continue
    
            if 'z' in position_indices and position_indices['z'] is not None:
                x_sym = MX.sym('x')
                y_sym = MX.sym('y')
                z_sym = MX.sym('z')
                h_sym = obstacle.get_constraint(x_sym, y_sym, z_sym)
                grad_h = [jacobian(h_sym, v) for v in [x_sym, y_sym, z_sym]]
                x_lin = state_lin[position_indices['x']]
                y_lin = state_lin[position_indices['y']]
                z_lin = state_lin[position_indices['z']]
                h_lin = obstacle.get_constraint(x_lin, y_lin, z_lin)
                grad_h_val = casadi.substitute(grad_h, [x_sym, y_sym, z_sym], [x_lin, y_lin, z_lin])
                x = state_vars[position_indices['x']]
                y = state_vars[position_indices['y']]
                z = state_vars[position_indices['z']]
                lin_constraint = h_lin + sum([g * (v - v_lin) for g, v, v_lin in zip(grad_h_val, [x, y, z], [x_lin, y_lin, z_lin])])
            else:
                x_sym = MX.sym('x')
                y_sym = MX.sym('y')
                h_sym = obstacle.get_constraint(x_sym, y_sym)
                grad_h = [jacobian(h_sym, v) for v in [x_sym, y_sym]]
                x_lin = state_lin[position_indices['x']]
                y_lin = state_lin[position_indices['y']]
                h_lin = obstacle.get_constraint(x_lin, y_lin)
                grad_h_val = casadi.substitute(grad_h, [x_sym, y_sym], [x_lin, y_lin])
                x = state_vars[position_indices['x']]
                y = state_vars[position_indices['y']]
                lin_constraint = h_lin + sum([g * (v - v_lin) for g, v, v_lin in zip(grad_h_val, [x, y], [x_lin, y_lin])])
    
            constraints.append(lin_constraint)
            bounds.append(obstacle.get_bounds())
        return constraints, bounds


# Fonctions utilitaires pour créer rapidement des obstacles
def create_circle(center_x, center_y, radius, name="circle"):
    """Crée un obstacle circulaire"""
    return CircleObstacle(center_x, center_y, radius, name)

def create_sphere(center_x, center_y, center_z, radius, name="sphere"):
    """Crée un obstacle sphérique"""
    return SphereObstacle(center_x, center_y, center_z, radius, name)

def create_rectangle(x_min, x_max, y_min, y_max, name="rectangle"):
    """Crée un obstacle rectangulaire"""
    return RectangleObstacle(x_min, x_max, y_min, y_max, name)

def create_box(x_min, x_max, y_min, y_max, z_min, z_max, name="box"):
    """Crée un obstacle parallélépipédique"""
    return BoxObstacle(x_min, x_max, y_min, y_max, z_min, z_max, name)
